"""
Generates plots / figures when run as a script.
Plot files are placed in the :file:`plots` directory.

By default, simply running ``python -m src.plots`` generates **ALL** plots,
which may not be desired.  Instead, one can pass a list of plots to generate:
``python -m src.plots plot1 plot2 ...``.  The full list of plots is shown in
the usage information ``python -m src.plots --help``.

Typing can be reduced by using shell brace expansion, e.g. ``python -m
src.plots observables_{design,posterior}`` for both ``observables_design`` and
``observables_posterior``.  In addition, plots may be given as paths to plot
filenames, which enables shell globbing, e.g. ``python -m src.plots
plots/observables_*``.

In the code, each plot is generated by a function tagged with the ``@plot``
decorator.
"""

from collections import OrderedDict, Counter, Mapping
import itertools
import logging
import os
from pathlib import Path
import subprocess
import tempfile
import warnings

import h5py
import hsluv
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import lines
from matplotlib import patches
from matplotlib import ticker
from matplotlib import cm
from matplotlib.colors import ListedColormap

from scipy import special
from scipy.interpolate import interp1d, PchipInterpolator
from scipy.optimize import brentq, curve_fit
from sklearn.decomposition import PCA
from sklearn.gaussian_process import GaussianProcessRegressor as GPR
from sklearn.gaussian_process import kernels
from sklearn.mixture import GaussianMixture
from sklearn.model_selection import KFold

from . import workdir, systems, parse_system, expt, model, mcmc
from .design import Design
from .emulator import Emulator, emulators

import freestream


# golden ratio
aspect = 1/1.618

# font sizes
fontsize = dict(
    large=11,
    normal=10,
    small=9,
    tiny=8,
)

# new tableau colors
# https://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782
colors = OrderedDict([
    ('blue', '#4e79a7'),
    ('orange', '#f28e2b'),
    ('green', '#59a14f'),
    ('red', '#e15759'),
    ('cyan', '#76b7b2'),
    ('purple', '#b07aa1'),
    ('brown', '#9c755f'),
    ('yellow', '#edc948'),
    ('pink', '#ff9da7'),
    ('gray', '#bab0ac')
])

offblack = '.15'
theme = '#b01419'

plt.rcdefaults()
plt.rcParams.update({
    'font.family': 'sans-serif',
    'font.sans-serif': ['Lato'],
    'mathtext.fontset': 'custom',
    'mathtext.default': 'it',
    'mathtext.rm': 'sans',
    'mathtext.cal': 'sans',
    'font.size': fontsize['normal'],
    'legend.fontsize': fontsize['normal'],
    'axes.labelsize': fontsize['normal'],
    'axes.titlesize': fontsize['large'],
    'xtick.labelsize': fontsize['small'],
    'ytick.labelsize': fontsize['small'],
    'font.weight': 400,
    'axes.labelweight': 400,
    'axes.titleweight': 400,
    'axes.prop_cycle': plt.cycler('color', list(colors.values())),
    'lines.linewidth': .8,
    'lines.markersize': 3,
    'lines.markeredgewidth': 0,
    'patch.linewidth': .8,
    'axes.linewidth': .6,
    'xtick.major.width': .6,
    'ytick.major.width': .6,
    'xtick.minor.width': .4,
    'ytick.minor.width': .4,
    'xtick.major.size': 3.,
    'ytick.major.size': 3.,
    'xtick.minor.size': 2.,
    'ytick.minor.size': 2.,
    'xtick.major.pad': 3.5,
    'ytick.major.pad': 3.5,
    'axes.labelpad': 4.,
    'axes.formatter.limits': (-5, 5),
    'axes.spines.top': False,
    'axes.spines.right': False,
    'text.color': offblack,
    'axes.edgecolor': offblack,
    'axes.labelcolor': offblack,
    'xtick.color': offblack,
    'ytick.color': offblack,
    'legend.frameon': False,
    'image.cmap': 'Blues',
    'image.interpolation': 'none',
})


plotdir = workdir / 'plots'
plotdir.mkdir(exist_ok=True)

plot_functions = {}


def plot(f):
    """
    Plot function decorator.  Calls the function, does several generic tasks,
    and saves the figure as the function name.

    """
    def wrapper(*args, **kwargs):
        logging.info('generating plot: %s', f.__name__)
        f(*args, **kwargs)

        fig = plt.gcf()

        plotfile = plotdir / '{}.pdf'.format(f.__name__)
        fig.savefig(str(plotfile))
        logging.info('wrote %s', plotfile)
        plt.close(fig)

    plot_functions[f.__name__] = wrapper

    return wrapper


def cmap_to_alpha(cmap=plt.cm.inferno, fraction=.2):
    """
    Fade the bottom of a colormap to white.

    Currently only works with ListedColormap objects, of which the new cmaps
    (inferno, magma, plasma, viridis) are examples.

    """
    try:
        colors = cmap.colors.copy()
        n = int(fraction*len(colors))

        for i, rgb in enumerate(colors[:n]):
            colors[i] = rgb + [i/n]

        return type(cmap)(colors, cmap.name + '_mod')
    except AttributeError:
        cmin = 25 if cmap == plt.cm.Oranges_r else 0
        colors = [list(cmap(n/256)) for n in range(cmin, 200)]
        n = int(fraction*len(colors))

        for i, rgb in enumerate(colors[:n]):
            rgb[-1] = i/n
            colors[i] = rgb

        return ListedColormap(colors, cmap.name + '_mod')


def figsize(relwidth=1, aspect=.618, refwidth=6):
    """
    Return figure dimensions from a relative width (to a reference width) and
    aspect ratio (default: 1/golden ratio).

    """
    width = relwidth * refwidth
    return width, width*aspect


def set_tight(fig=None, **kwargs):
    """
    Set tight_layout with a better default pad.

    """
    if fig is None:
        fig = plt.gcf()

    kwargs.setdefault('pad', .1)
    fig.set_tight_layout(kwargs)


def auto_ticks(ax, axis='both', minor=False, **kwargs):
    """
    Convenient interface to matplotlib.ticker locators.

    """
    axis_list = []

    if axis in {'x', 'both'}:
        axis_list.append(ax.xaxis)
    if axis in {'y', 'both'}:
        axis_list.append(ax.yaxis)

    for axis in axis_list:
        axis.get_major_locator().set_params(**kwargs)
        if minor:
            axis.set_minor_locator(ticker.AutoMinorLocator(minor))


def format_system(system):
    """
    Format a system string into a display name, e.g.:

    >>> format_system('PbPb2760')
    'Pb-Pb 2.76 TeV'

    >>> format_system('AuAu200')
    'Au-Au 200 GeV'

    """
    proj, energy = parse_system(system)

    if energy > 1000:
        energy /= 1000
        prefix = 'T'
    else:
        prefix = 'G'

    return '{} {} {}eV'.format('-'.join(proj), energy, prefix)


def darken(rgb, amount=.5):
    """
    Darken a color by the given amount in HSLuv space.

    """
    H, S, L = hsluv.rgb_to_hsluv(rgb)
    return hsluv.hsluv_to_rgb((H, S, (1 - amount)*L))


def obs_color_hsluv(obs, subobs):
    """
    Return a nice color for the given observable in HSLuv space.
    Use obs_color() to obtain an RGB color.

    """
    if obs in {'dNch_deta', 'pT_fluct', 'mean_pT'}:
        return 250, 90, 55

    if obs == 'dET_deta':
        return 10, 65, 55

    if obs in {'iden_dN_dy'}:
        return dict(
            charged=(250, 90, 55),
            pion=(210, 85, 70),
            kaon=(130, 88, 68),
            proton=(30, 90, 62),
        )[subobs]

    if obs == 'vnk':
        return {
            (2, 2): (230, 90, 65),
            (2, 4): (262, 80, 63),
            (3, 2): (150, 90, 67),
            (4, 2): (310, 70, 50),
        }[subobs]

    raise ValueError('unknown observable: {} {}'.format(obs, subobs))


def obs_color(obs, subobs):
    """
    Return a nice color for the given observable.

    """
    return hsluv.hsluv_to_rgb(obs_color_hsluv(obs, subobs))


def obs_label(obs, subobs, differentials=False, full_cumulants=False):
    """
    Return a formatted label for the given observable.

    """
    if obs.startswith('d') and obs.endswith('_deta'):
        return (r'$d{}/d\eta$' if differentials else '${}$').format(
            {'Nch': r'N_\mathrm{ch}', 'ET': r'E_T'}[obs[1:-5]])

    id_parts_labels = {
        'dN_dy': '$dN_{}/dy$' if differentials else '$N_{}$',
        'mean_pT': r'$\langle p_T^{} \rangle$'
    }
    if obs in id_parts_labels:
        return id_parts_labels[obs].format(
                {'pion': '\pi', 'kaon': 'K', 'proton': 'p', None: '{}'}[subobs]
        )

    if obs == 'pT_fluct':
        return r'$\delta p_T/\langle p_T \rangle$'

    if obs == 'vnk':
        n, k = subobs
        return '$v_{}{}$'.format(
            n,
            (r'\{' + str(k) + r'\}') if full_cumulants else ''
        )


def _observables_plots():
    """
    Metadata for observables plots.

    """
    def id_parts_plots(obs):
        return [(obs, species, dict(label=label)) for species, label in [
            ('pion', '$\pi$'), ('kaon', '$K$'), ('proton', '$p$')
        ]]

    return [
        dict(
            title='Yields',
            ylabel=(r'$dN_\mathrm{ch}/d\eta$'),
            ylim=(10**0, 10**3),
            yscale='log',
            height_ratio=1,
            subplots=[
                ('dNch_deta', None, dict(label=r'$N_\mathrm{ch}$', scale=1)),
            ]
        ),
        dict(
            title='Mean $p_T$',
            ylabel=r'$\langle p_T \rangle$ [GeV]',
            ylim=(0, 2),
            subplots=[
                ('mean_pT', None, dict(label=r'$\mathrm{mean}\ p_T$', scale=1)),
            ]
        ),
        dict(
            title='Flow cumulants',
            ylabel=r'$v_n\{2\}$',
            ylim=(0, .2),
            subplots=[
                ('vnk', (n, 2), dict(label='$v_{}$'.format(n)))
                for n in [2, 3]
            ]
        )
    ]


def _observables(posterior=False):
    """
    Model observables at all design points or drawn from the posterior with
    experimental data points.

    """
    plots = _observables_plots()

    fig, axes = plt.subplots(
        nrows=len(plots), ncols=len(systems),
        figsize=figsize(1.1, aspect=1.25),
        gridspec_kw=dict(
            height_ratios=[p.get('height_ratio', 1) for p in plots]
        )
    )

    if posterior:
        samples = mcmc.Chain().samples(100)

    for (plot, system), ax in zip(itertools.product(plots, systems), axes.flat):
        for obs, subobs, opts in plot['subplots']:
            color = obs_color(obs, subobs)
            scale = opts.get('scale')

            try:
                x = model.data[system][obs][subobs]['x']
                Y = (
                    samples[system][obs][subobs]
                    if posterior else
                    model.data[system][obs][subobs]['Y']
                )
            except KeyError:
                continue

            if scale is not None:
                Y = Y*scale

            for y in Y:
                ax.plot(x, y, color=color, alpha=.08, lw=.3)

            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                print(system, obs, subobs, 'not found')
                pass
            else:
                x = dset['x']
                y = dset['y']
                yerr = np.sqrt(sum(
                    e**2 for e in dset['yerr'].values()
                ))

                if scale is not None:
                    y = y*scale
                    yerr = yerr*scale

                ax.errorbar(
                    x, y, yerr=yerr, fmt='o',
                    capsize=0, color='.25', zorder=1000
                )

            if system == 'pPb5020' and obs == 'mean_pT':
                ax.set_xlim(1, 6)
                ax.set_xlabel(r'$N_\mathrm{ch}\,/\langle N_\mathrm{ch} \rangle$')
            elif system == 'pPb5020' and obs == 'vnk':
                ax.set_xlim(1, 6)
                ax.set_xlabel('/'.join([
                    r'$N^\mathrm{offline}_\mathrm{trk}$',
                    r'$\langle N^\mathrm{offline}_\mathrm{trk} \rangle$',
                ]))
            else:
                ax.set_xlim(0, 55)
                ax.set_xlabel('Centrality %')

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        auto_ticks(ax, 'x', nbins=5, minor=2)

        ax.set_ylim(plot['ylim'])

        if ax.is_first_row():
            ax.set_title(format_system(system), y=.9)

        if ax.is_first_col():
            ax.set_ylabel(plot['ylabel'])

        #if ax.is_last_col():
        #    ax.text(
        #        1.02, .5, plot['title'],
        #        transform=ax.transAxes, ha='left', va='center',
        #        size=plt.rcParams['axes.labelsize'], rotation=-90
        #    )
        #    ax.set_yticklabels([])

    set_tight(fig, rect=[0, 0, .97, 1])


@plot
def observables_design():
    _observables(posterior=False)


@plot
def observables_posterior():
    _observables(posterior=True)


#@plot
def observables_map():
    """
    Model observables and ratio to experiment at the maximum a posteriori
    (MAP) estimate.

    """
    plots = _observables_plots()

    ylim = {
        'Yields': (2, 1e5),
        'Flow cumulants': (0, .15),
        'Mean $p_T$': (0, 1.7),
        'Mean $p_T$ fluctuations': (0, .045),
    }

    for n, p in enumerate(plots):
        p['ylim'] = ylim[p['title']]
        if p['title'] == 'Flow cumulants':
            move_index = n
            p.update(
                ylabel=r'$v_n\{k\}$',
                subplots=[
                    ('vnk', nk, dict(label='$v_{}\{{{}\}}$'.format(*nk)))
                    for nk in [(2, 2), (2, 4), (3, 2), (4, 2)]
                ],
                legend=True
            )

    plots.insert(1, plots.pop(move_index))

    ncols = int(len(plots)/2)

    fig, axes = plt.subplots(
        nrows=4, ncols=ncols,
        figsize=figsize(1.1, aspect=2/ncols),
        gridspec_kw=dict(
            height_ratios=list(itertools.chain.from_iterable(
                (p.get('height_ratio', 1), .4) for p in plots[::ncols]
            ))
        )
    )

    labels = {}
    handles = dict(expt={}, model={})

    for plot, ax, ratio_ax in zip(plots, axes[::2].flat, axes[1::2].flat):
        for system, (obs, subobs, opts) in itertools.product(
                systems, plot['subplots']
        ):
            color = obs_color(obs, subobs)
            scale = opts.get('scale')

            linestyle, fill_markers = {
                'PbPb2760': ('solid', True),
                'PbPb5020': ('dashed', False),
            }[system]

            x = model.map_data[system][obs][subobs]['x']
            y = model.map_data[system][obs][subobs]['Y']

            if scale is not None:
                y = y*scale

            ax.plot(x, y, color=color, ls=linestyle)
            handles['model'][system] = \
                lines.Line2D([], [], color=offblack, ls=linestyle)

            if 'label' in opts and (obs, subobs) not in labels:
                labels[obs, subobs] = ax.text(
                    x[-1] + 3, y[-1],
                    opts['label'],
                    color=darken(color), ha='left', va='center'
                )

            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                continue

            x = dset['x']
            yexp = dset['y']
            yerr = dset['yerr']
            yerrstat = yerr.get('stat')
            yerrsys = yerr.get('sys', yerr.get('sum'))

            if scale is not None:
                yexp = yexp*scale
                if yerrstat is not None:
                    yerrstat = yerrstat*scale
                if yerrsys is not None:
                    yerrsys = yerrsys*scale

            c = '.25'
            handles['expt'][system] = ax.errorbar(
                x, yexp, yerr=yerrstat, fmt='o',
                capsize=0, color=c,
                mec=c, mfc=(c if fill_markers else '.9'),
                mew=((.2 if fill_markers else .5) *
                     plt.rcParams['lines.linewidth']),
                zorder=1000
            )

            ax.fill_between(
                x, yexp - yerrsys, yexp + yerrsys,
                facecolor='.9', zorder=-10,
            )

            ratio_ax.plot(x, y/yexp, color=color, ls=linestyle)

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        for a in [ax, ratio_ax]:
            a.set_xlim(0, 80)
            auto_ticks(a, 'x', nbins=5, minor=2)

        if ratio_ax.is_last_row():
            ratio_ax.set_xlabel('Centrality %')

        ax.set_ylim(plot['ylim'])
        ax.set_ylabel(plot['ylabel'])

        if plot.get('legend'):
            ax.legend(
                [handles[t][s] for t in ['model', 'expt'] for s in systems],
                [fmt.format(parse_system(s)[1]/1000)
                 for fmt in ['', '{} TeV'] for s in systems],
                ncol=2, loc='upper left', bbox_to_anchor=(0, .94),
                columnspacing=0, handletextpad=0
            )

        ax.text(
            .5, 1 if ax.is_first_row() else .97, plot['title'],
            transform=ax.transAxes, ha='center', va='top',
            size=plt.rcParams['axes.labelsize']
        )

        ratio_ax.axhline(
            1,
            linewidth=plt.rcParams['ytick.major.width'], color='0.5',
            zorder=-100
        )
        ratio_ax.axhspan(.9, 1.1, color='0.93', zorder=-200)
        ratio_ax.set_ylim(.85, 1.15)
        ratio_ax.set_ylabel('Ratio')
        ratio_ax.text(
            ratio_ax.get_xlim()[1], .9, '±10%',
            color='.5', zorder=-50,
            ha='right', va='bottom',
            size=plt.rcParams['xtick.labelsize']
        )

    set_tight(fig)


@plot
def find_map():
    """
    Find the maximum a posteriori (MAP) point and compare emulator predictions
    to experimental data.

    """
    from scipy.optimize import minimize

    chain = mcmc.Chain()

    fixed_params = {
        'trento_p': 0.,
        'etas_min': .08,
        'etas_slope': 1.1285,
        'etas_crv': -0.5365,
        'etas_hrg': .3,
        'zetas_max': 0.0536,
        'zetas_width': 0.0194,
        'zetas_t0': 0.1824,
        'Tswitch': 0.1515,
        'model_sys_err': .1,
    }

    opt_params = [k for k in chain.keys if k not in fixed_params]

    def full_x(x):
        x = dict(zip(opt_params, x), **fixed_params)
        return [x[k] for k in chain.keys]

    res = minimize(
        lambda x: -chain.log_posterior(full_x(x))[0],
        x0=np.median(chain.load(*opt_params, thin=1000), axis=0),
        tol=1e-8,
        bounds=[
            (a + 1e-6*(b - a), b - 1e-6*(b - a))
            for (a, b), k in zip(chain.range, chain.keys)
            if k in opt_params
        ]
    )

    logging.debug('optimization result:\n%s', res)
    width = max(map(len, chain.keys)) + 2
    logging.info(
        'MAP params:\n%s',
        '\n'.join(
            k.ljust(width) + str(x) for k, x in zip(chain.keys, full_x(res.x))
        )
    )

    pred = chain._predict(np.atleast_2d(full_x(res.x)))

    plots = _observables_plots()

    fig, axes = plt.subplots(
        nrows=2*len(plots), ncols=len(systems),
        figsize=figsize(1.1, 2),
        gridspec_kw=dict(
            height_ratios=list(itertools.chain.from_iterable(
                (p.get('height_ratio', 1), .4) for p in plots
            ))
        )
    )

    for (plot, system), ax, ratio_ax in zip(
            itertools.product(plots, systems), axes[::2].flat, axes[1::2].flat
    ):
        for obs, subobs, opts in plot['subplots']:
            color = obs_color(obs, subobs)
            scale = opts.get('scale')

            x = model.data[system][obs][subobs]['x']
            y = pred[system][obs][subobs][0]

            if scale is not None:
                y = y*scale

            ax.plot(x, y, color=color)

            if 'label' in opts:
                ax.text(
                    x[-1] + 3, y[-1],
                    opts['label'],
                    color=darken(color), ha='left', va='center'
                )

            try:
                dset = expt.data[system][obs][subobs]
            except KeyError:
                continue

            x = dset['x']
            yexp = dset['y']
            yerr = dset['yerr']
            yerrstat = yerr.get('stat')
            yerrsys = yerr.get('sys', yerr.get('sum'))

            if scale is not None:
                yexp = yexp*scale
                if yerrstat is not None:
                    yerrstat = yerrstat*scale
                if yerrsys is not None:
                    yerrsys = yerrsys*scale

            ax.errorbar(
                x, yexp, yerr=yerrstat, fmt='o', ms=1.7,
                capsize=0, color='.25', zorder=1000
            )

            ax.fill_between(
                x, yexp - yerrsys, yexp + yerrsys,
                color='.9', zorder=-10
            )

            ratio_ax.plot(x, y/yexp, color=color)

        if plot.get('yscale') == 'log':
            ax.set_yscale('log')
            ax.minorticks_off()
        else:
            auto_ticks(ax, 'y', nbins=4, minor=2)

        ax.set_xticklabels([])

        ax.set_ylim(plot['ylim'])

        if ax.is_first_row():
            ax.set_title(format_system(system))
        elif ax.is_last_row():
            ax.set_xlabel('Centrality %')

        if ax.is_first_col():
            ax.set_ylabel(plot['ylabel'])

        if ax.is_last_col():
            ax.text(
                1.02, .5, plot['title'],
                transform=ax.transAxes, ha='left', va='center',
                size=plt.rcParams['axes.labelsize'], rotation=-90
            )

        ratio_ax.axhline(1, lw=.5, color='0.5', zorder=-100)
        ratio_ax.axhspan(0.9, 1.1, color='0.95', zorder=-200)
        ratio_ax.set_ylim(0.8, 1.2)
        ratio_ax.set_yticks(np.arange(80, 121, 20)/100)
        ratio_ax.set_ylabel('Ratio')

    set_tight(fig, rect=[0, 0, .97, 1])


def format_ci(samples, ci=.9):
    """
    Compute the median and a credible interval for an array of samples and
    return a TeX-formatted string.

    """
    cil, cih = mcmc.credible_interval(samples, ci=ci)
    median = np.median(samples)
    ul = median - cil
    uh = cih - median

    # decide precision for formatting numbers
    # this is NOT general but it works for the present data
    if abs(median) < .05 or (uh + ul) < abs(median) < .5:
        precision = 3
    elif abs(median) < 5:
        precision = 2
    else:
        precision = 1

    fmt = str(precision).join(['{:#.', 'f}'])

    return ''.join([
        '$', fmt.format(median),
        '_{-', fmt.format(ul), '}',
        '^{+', fmt.format(uh), '}$'
    ])


def _posterior(
        params=None, ignore=None,
        scale=1, pad_subplots=-.1, rect_r=1, rect_t=.99,
        cmap=None
):
    """
    Triangle plot of posterior marginal and joint distributions.

    """
    chain = mcmc.Chain()

    if params is None and ignore is None:
        params = set(chain.keys)
    elif params is not None:
        params = set(params)
    elif ignore is not None:
        params = set(chain.keys) - set(ignore)

    keys, labels, ranges = map(list, zip(*(
        i for i in zip(chain.keys, chain.labels, chain.range)
        if i[0] in params
    )))
    ndim = len(params)

    data = chain.load(*keys).T

    cmap = plt.get_cmap(cmap)
    cmap.set_bad('white')

    line_color = cmap(.8)
    fill_color = cmap(.5, alpha=.1)

    fig, axes = plt.subplots(
        nrows=ndim, ncols=ndim,
        sharex='col', sharey='row',
        figsize=figsize(.15*scale*ndim, aspect=1)
    )

    for samples, key, lim, ax in zip(data, keys, ranges, axes.diagonal()):
        counts, edges = np.histogram(samples, bins=50, range=lim)
        x = (edges[1:] + edges[:-1]) / 2
        y = .85 * (lim[1] - lim[0]) * counts / counts.max() + lim[0]
        # smooth histogram with monotonic cubic interpolation
        interp = PchipInterpolator(x, y)
        x = np.linspace(x[0], x[-1], 10*x.size)
        y = interp(x)
        ax.plot(x, y, linewidth=1, color=line_color)
        ax.fill_between(x, lim[0], y, color=fill_color, zorder=-10)

        ax.set_xlim(lim)
        ax.set_ylim(lim)

        if key == 'dmin3':
            samples = samples**(1/3)

        ax.annotate(
            format_ci(samples), (.62, .92), xycoords='axes fraction',
            ha='center', va='bottom', fontsize=fontsize['large']
        )

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        axes[ny][nx].hist2d(
            data[nx], data[ny], bins=100,
            range=(ranges[nx], ranges[ny]),
            cmap=cmap, cmin=1
        )
        axes[nx][ny].set_axis_off()

    for ax in axes.flat:
        ax.tick_params(length=2/3*plt.rcParams['xtick.major.size'])

    for key, label, axb, axl in zip(keys, labels, axes[-1], axes[:, 0]):
        for axis in [axb.xaxis, axl.yaxis]:
            axis.set_label_text(
                label.replace(r'\ [', '$\n$['),
            )
            axis.set_tick_params(labelsize=fontsize['tiny'])
            if key == 'dmin3':
                ticks = [0., 1.2, 1.5, 1.7]
                axis.set_ticklabels(list(map(str, ticks)))
                axis.set_ticks([t**3 for t in ticks])
            else:
                axis.set_major_locator(ticker.LinearLocator(3))
                if axis.axis_name == 'x' and any(
                        len(str(round(x, 5))) > 4 for x in axis.get_ticklocs()
                ):
                    for t in axis.get_ticklabels():
                        t.set_rotation(30)

        axb.get_xticklabels()[0].set_horizontalalignment('left')
        axb.get_xticklabels()[-1].set_horizontalalignment('right')
        axl.get_yticklabels()[0].set_verticalalignment('bottom')
        axl.get_yticklabels()[-1].set_verticalalignment('top')

    set_tight(
        fig, pad=0, w_pad=pad_subplots, h_pad=pad_subplots,
        rect=(0, 0, rect_r, rect_t)
    )


@plot
def posterior():
    _posterior(ignore={'etas_hrg'})


@plot
def posterior_shear():
    _posterior(
        scale=1.35, pad_subplots=.1, rect_t=.97,
        params={'etas_min', 'etas_slope', 'etas_crv'}
    )


@plot
def posterior_bulk():
    _posterior(
        scale=1.35, pad_subplots=.1, rect_t=.97,
        params={'zetas_max', 'zetas_width', 'zetas_t0'}
    )


@plot
def posterior_p():
    """
    Distribution of trento p parameter with annotations for other models.

    """
    plt.figure(figsize=figsize(.8, .35))
    ax = plt.axes()

    data = mcmc.Chain().load('trento_p').ravel()

    counts, edges = np.histogram(data, bins=50)
    x = (edges[1:] + edges[:-1]) / 2
    y = counts / counts.max()
    interp = PchipInterpolator(x, y)
    x = np.linspace(x[0], x[-1], 10*x.size)
    y = interp(x)
    ax.plot(x, y, color=plt.cm.Blues(0.8))
    ax.fill_between(x, y, color=plt.cm.Blues(0.15), zorder=-10)

    ax.set_xlabel('$p$')

    for spine in ax.spines.values():
        spine.set_visible(False)

    for label, x, err in [
            ('KLN', -.67, .01),
            ('EKRT /\nIP-Glasma', 0, .1),
            ('Wounded\nnucleon', 1, None),
    ]:
        args = ([x], [0], 'o') if err is None else ([x - err, x + err], [0, 0])
        ax.plot(*args, lw=4, ms=4, color=offblack, alpha=.58, clip_on=False)

        if label.startswith('EKRT'):
            x -= .29

        ax.text(x, .05, label, va='bottom', ha='center')

    ax.text(.1, .8, format_ci(data))
    ax.set_xticks(np.arange(-10, 11, 5)/10)
    ax.set_xticks(np.arange(-75, 76, 50)/100, minor=True)

    xm = 1.2
    ax.set_xlim(-xm, xm)
    ax.add_artist(
        patches.FancyArrowPatch(
            (-xm, 0), (xm, 0),
            linewidth=plt.rcParams['axes.linewidth'],
            arrowstyle=patches.ArrowStyle.CurveFilledAB(
                head_length=3, head_width=1.5
            ),
            facecolor=offblack, edgecolor=offblack,
            clip_on=False, zorder=100
        )
    )

    ax.set_yticks([])
    ax.set_ylim(0, 1.01*y.max())

    set_tight(pad=0)


@plot
def region_shear_bulk(cmap=plt.cm.Blues):
    """
    Visual estimates (posterior median and credible region) of the
    temperature-dependent shear and bulk viscosity.

    """
    fig, axes = plt.subplots(ncols=2, figsize=figsize(1, .4))

    Tmin, Tmax = .150, .300
    Tc = .154

    chain = mcmc.Chain()

    for (name,  var, keys, function, ymax), ax in zip([
            ('shear', 'eta', ['min', 'slope', 'crv'],
             lambda T, m, s, c: m + s*(T - Tc)*(T/Tc)**c,
             .4),
            ('bulk', 'zeta', ['max', 'width', 't0'],
             lambda T, m, w, T0: m / (1 + ((T - T0)/w)**2),
             .08)
    ], axes):
        samples = chain.load(*['{}s_{}'.format(var, k) for k in keys])

        T = np.linspace(Tc if name == 'shear' else Tmin, Tmax, 1000)
        ax.plot(
            T, function(T, *np.median(samples, axis=0)),
            color=cmap(.75), label='Posterior median'
        )

        Tsparse = np.linspace(T[0], T[-1], 25)
        intervals = [
            PchipInterpolator(Tsparse, y)(T)
            for y in np.array([
                mcmc.credible_interval(function(t, *samples.T))
                for t in Tsparse
            ]).T
        ]
        ax.fill_between(
            T, *intervals,
            color=cmap(.3), label='90% credible region'
        )

        ax.set_xlim(Tmin, Tmax)
        ax.set_ylim(0, ymax)
        auto_ticks(ax, nbins=5)
        ax.xaxis.set_major_formatter(
            ticker.FuncFormatter(lambda x, pos: int(1000*x))
        )

        ax.set_xlabel('Temperature [MeV]')
        ax.set_ylabel(r'$\{}/s$'.format(var))
        ax.set_title(name.capitalize() + ' viscosity')

        if name == 'shear':
            ax.axhline(
                1/(4*np.pi),
                color='.5', linewidth=plt.rcParams['ytick.major.width']
            )
            ax.text(Tmax, .07, r'$1/4\pi$', va='top', ha='right', color='.3')
            ax.legend(loc='upper left')

    set_tight(w_pad=.2)


region_style = dict(color='.93', zorder=-100)
Tc = .154


#@plot
def flow_corr():
    """
    Symmetric cumulants SC(m, n) at the MAP point compared to experiment.

    """
    fig, axes = plt.subplots(
        figsize=figsize(1.05, .7),
        nrows=2, ncols=2, gridspec_kw=dict(width_ratios=[.8, 1])
    )

    cmapx_normal = .7
    cmapx_pred = .5

    def label(*mn, normed=False):
        fmt = r'\mathrm{{SC}}({0}, {1})'
        if normed:
            fmt += r'/\langle v_{0}^2 \rangle\langle v_{1}^2 \rangle'
        return fmt.format(*mn).join('$$')

    for obs, ax in zip(
            ['sc_central', 'sc', 'sc_normed_central', 'sc_normed'],
            axes.flat
    ):
        for (mn, cmap), sys in itertools.product(
                [
                    ((4, 2), 'Blues'),
                    ((3, 2), 'Oranges'),
                ],
                systems
        ):
            x = model.map_data[sys][obs][mn]['x']
            y = model.map_data[sys][obs][mn]['Y']

            pred = obs not in expt.data[sys]
            cmapx = cmapx_pred if pred else cmapx_normal

            kwargs = {}

            if pred:
                kwargs.update(linestyle='dashed')

            if ax.is_first_col() and ax.is_first_row():
                fmt = '{:.2f} TeV'
                if pred:
                    fmt += ' (prediction)'
                lbl = fmt.format(parse_system(sys)[1]/1000)
                if not any(l.get_label() == lbl for l in ax.get_lines()):
                    ax.add_line(lines.Line2D(
                        [], [], color=plt.cm.Greys(cmapx),
                        label=lbl, **kwargs
                    ))
            elif ax.is_last_col() and not pred:
                kwargs.update(label=label(*mn, normed='normed' in obs))

            ax.plot(
                x, y, lw=.75,
                color=getattr(plt.cm, cmap)(cmapx),
                **kwargs
            )

            if pred:
                continue

            x = expt.data[sys][obs][mn]['x']
            y = expt.data[sys][obs][mn]['y']
            yerr = expt.data[sys][obs][mn]['yerr']

            ax.errorbar(
                x, y, yerr=yerr['stat'],
                fmt='o', ms=.8*plt.rcParams['lines.markersize'],
                capsize=0, color='.25', zorder=100
            )

            ax.fill_between(
                x, y - yerr['sys'], y + yerr['sys'],
                color='.9', zorder=-10
            )

        ax.axhline(
            0, color='.5', lw=plt.rcParams['xtick.major.width'],
            zorder=-100
        )

        ax.set_xlim(0, 10 if 'central' in obs else 70)

        auto_ticks(ax, nbins=6, minor=2)

        if all(ax.get_legend_handles_labels()):
            ax.legend(loc='best')

        if ax.is_first_col():
            ax.set_ylabel(label('m', 'n', normed='normed' in obs))

        if ax.is_first_row():
            ax.set_title(
                'Central'
                if 'central' in obs else
                'Minimum bias'
            )
        else:
            ax.set_xlabel('Centrality %')


#@plot
def flow_extra():
    """
    vn{2} in central bins and v2{4}.

    """
    plots, width_ratios = zip(*[
        (('vnk_central', 'Central two-particle cumulants', r'$v_n\{2\}$'), 2),
        (('vnk', 'Four-particle cumulants', r'$v_2\{4\}$'), 3),
    ])

    fig, axes = plt.subplots(
        figsize=figsize(1.2, aspect=.4),
        ncols=len(plots), gridspec_kw=dict(width_ratios=width_ratios)
    )

    cmaps = {
        (2, 2): plt.cm.GnBu,
        (3, 2): plt.cm.Purples,
        (4, 2): plt.cm.RdPu,
        (2, 4): plt.cm.OrRd,
    }

    for (obs, title, ylabel), ax in zip(plots, axes):
        for sys, (cmapx, dashes, fmt) in zip(
                systems, [
                    (.7, (None, None), 'o'),
                    (.6, (3, 2), 's'),
                ]
        ):
            syslabel = '{:.2f} TeV'.format(parse_system(sys)[1]/1000)
            for subobs, dset in model.map_data[sys][obs].items():
                x = dset['x']
                y = dset['Y']

                ax.plot(
                    x, y,
                    color=cmaps[subobs](cmapx), dashes=dashes,
                    label='Model ' + syslabel
                )

                try:
                    dset = expt.data[sys][obs][subobs]
                except KeyError:
                    continue

                x = dset['x']
                y = dset['y']
                yerr = dset['yerr']

                ax.errorbar(
                    x, y, yerr=yerr['stat'],
                    fmt=fmt, ms=2.2, capsize=0, color='.25', zorder=100,
                    label='ALICE ' + syslabel
                )

                ax.fill_between(
                    x, y - yerr['sys'], y + yerr['sys'],
                    color='.9', zorder=-10
                )

                if obs == 'vnk_central':
                    ax.text(
                        x[-1] + .15, y[-1], '$v_{}$'.format(subobs),
                        color=cmaps[subobs](.99), ha='left', va='center'
                    )

        auto_ticks(ax, 'y', minor=2)
        ax.set_xlim(0, dset['cent'][-1][1])

        ax.set_xlabel('Centrality %')
        ax.set_ylabel(ylabel)
        ax.set_title(title)

    handles, labels = ax.get_legend_handles_labels()
    ax.legend(handles[-2:], labels[-1:], loc='upper left')
    set_tight(fig, pad=.2)


@plot
def design():
    """
    Projection of a LH design into two dimensions.

    """
    fig = plt.figure(figsize=figsize(.5, 1))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    d = Design(systems[0])

    keys = ('etas_min', 'etas_slope')
    indices = tuple(d.keys.index(k) for k in keys)

    x, y = (d.array[:, i] for i in indices)
    ax_j.plot(x, y, 'o', color=plt.cm.Blues(0.75), mec='white', mew=.3)

    hist_kw = dict(bins=30, color=plt.cm.Blues(0.4), edgecolor='white', lw=.5)
    ax_x.hist(x, **hist_kw)
    ax_y.hist(y, orientation='horizontal', **hist_kw)

    for ax in fig.axes:
        ax.tick_params(top='off', right='off')
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')

    auto_ticks(ax_j)

    for ax in ax_x, ax_y:
        ax.tick_params(labelbottom='off', labelleft='off')

    for i, xy in zip(indices, 'xy'):
        for f, l in [('lim', d.range), ('label', d.labels)]:
            getattr(ax_j, 'set_{}{}'.format(xy, f))(l[i])


@plot
def gp():
    """
    Conditioning a Gaussian process.

    """
    fig, axes = plt.subplots(
        figsize=figsize(.5, 2*aspect),
        nrows=2, sharex='col'
    )

    def dummy_optimizer(obj_func, initial_theta, bounds):
        return initial_theta, 0.

    gp = GPR(1.*kernels.RBF(.8), optimizer=dummy_optimizer)

    def sample_y(*args, **kwargs):
        with warnings.catch_warnings():
            warnings.simplefilter('ignore', RuntimeWarning)
            return gp.sample_y(*args, **kwargs)

    x = np.linspace(0, 5, 1000)
    X = x[:, np.newaxis]

    x_train = np.linspace(.5, 4.5, 4)
    X_train = x_train[:, np.newaxis]

    for title, ax in zip(['Random functions', 'Conditioned on data'], axes):
        if title.startswith('Conditioned'):
            y = sample_y(X_train, random_state=23158).squeeze()
            y -= .5*(y.max() + y.min())
            gp.fit(X_train, y)
            training_data, = plt.plot(x_train, y, 'o', color='.3', zorder=50)

        for s, c in zip(
                sample_y(X, n_samples=4, random_state=34576).T,
                ['Blues', 'Greens', 'Oranges', 'Purples']
        ):
            ax.plot(x, s, color=getattr(plt.cm, c)(.6))

        mean, std = gp.predict(X, return_std=True)
        std = ax.fill_between(x, mean - std, mean + std, color='.92')
        mean, = ax.plot(x, mean, color='.42', dashes=(3.5, 1.5))

        ax.set_ylim(-2, 2)
        ax.set_ylabel('Output')
        auto_ticks(ax)

        ax.set_title(title, y=.9)

    ax.set_xlabel('Input')
    ax.legend(*zip(*[
        (mean, 'Mean prediction'),
        (std, 'Uncertainty'),
        (training_data, 'Training data'),
    ]), loc='lower left')

    set_tight(fig, h_pad=1)


@plot
def pca():
    fig = plt.figure(figsize=figsize(.5, 1))
    ratio = 5
    gs = plt.GridSpec(ratio + 1, ratio + 1)

    ax_j = fig.add_subplot(gs[1:, :-1])
    ax_x = fig.add_subplot(gs[0, :-1], sharex=ax_j)
    ax_y = fig.add_subplot(gs[1:, -1], sharey=ax_j)

    x, y = (
        model.data['pPb5020'][obs][subobs]['Y'][:, 0]
        for obs, subobs in [('dNch_deta', None), ('vnk', (2, 2))]
    )
    x = np.log(x + 1e-1*np.random.uniform(1e-2, 1e-1, len(x)))
    y = np.log(y)
    xlabel = r'$dN_{\pi^\pm}/dy$'
    ylabel = r'$v_2\{2\}$'
    #xlim = 0.001, 100
    #ylim = 0.001, 0.3

    cmap = plt.cm.Blues

    ax_j.plot(x, y, 'o', color=cmap(.75), mec='white', mew=.25, zorder=10)

    for d, ax, orientation in [(x, ax_x, 'vertical'), (y, ax_y, 'horizontal')]:
        ax.hist(
            d, bins=20,
            orientation=orientation, color=cmap(.4), edgecolor='white'
        )

    xy = np.column_stack([x, y])
    xymean = xy.mean(axis=0)
    xystd = xy.std(axis=0)
    xy -= xymean
    xy /= xystd
    pca = PCA().fit(xy)
    pc = (
        7 * xystd *
        pca.explained_variance_ratio_[:, np.newaxis] *
        pca.components_
    )

    for w, p in zip(pca.explained_variance_ratio_, pc):
        if np.all(p < 0):
            p *= -1
        ax_j.annotate(
            '', xymean + p, xymean, zorder=20,
            arrowprops=dict(
                arrowstyle='->', shrinkA=0, shrinkB=0,
                color=offblack, lw=.7
            )
        )
        ax_j.text(
            *(xymean + p + (.8, .002)*np.sign(p)), s='{:.0f}%'.format(100*w),
            color=offblack, ha='center', va='top' if p[1] < 0 else 'bottom',
            zorder=20
        )

    for ax in fig.axes:
        ax.tick_params(top='off', right='off')
        spines = ['top', 'right']
        if ax is ax_x:
            spines += ['left']
        elif ax is ax_y:
            spines += ['bottom']
        for spine in spines:
            ax.spines[spine].set_visible(False)
        for ax_name in 'xaxis', 'yaxis':
            getattr(ax, ax_name).set_ticks_position('none')

    for ax in ax_x, ax_y:
        ax.tick_params(labelbottom='off', labelleft='off')

    auto_ticks(ax_j)

    #ax_j.set_xlim(-5, 5)
    #ax_j.set_ylim(ylim)

    #ax_j.set_xlabel(xlabel)
    #ax_j.set_ylabel(ylabel)

    set_tight(pad=.1, h_pad=.3, w_pad=.3)


@plot
def pca_vectors_variance(system='pPb5020'):
    """
    PCA vectors and explained variance.

    """
    fig, axes = plt.subplots(
        figsize=figsize(1.2, aspect=.4),
        ncols=2, gridspec_kw=dict(width_ratios=[5, 1])
    )

    emu = emulators[system]
    pca = emu.pca

    ax = axes[0]

    for n, (pc, var) in enumerate(zip(
            pca.components_[:3], pca.explained_variance_ratio_
    ), start=1):
        ax.plot(pc, 'o', label='PC {} ({:.0f}%)'.format(n, 100*var))

    ax.axhline(
        0,
        color='.5', linewidth=plt.rcParams['ytick.major.width'],
        zorder=-100
    )

    x = -.5
    ticks = []
    ticklabels = []

    for obs, subobslist in emu.pPb5020:
        for subobs in subobslist:
            i = model.data[system][obs][subobs]['Y'].shape[1]
            ticks.append(x + .5*i)
            ticklabels.append(obs_label(obs, subobs))
            x += i

    ax.set_xticks(ticks)
    ax.set_xticklabels(ticklabels)
    ax.tick_params(
        'x',
        bottom=False, labelbottom=False,
        labeltop=True, pad=1
    )
    for t in ax.get_xticklabels():
        t.set_verticalalignment('baseline')

    #ax.set_ylim(-.2, .35)
    ax.set_ylabel('PCA coefficient', labelpad=1)
    auto_ticks(ax, 'y', nbins=4, minor=2)
    ax.legend(loc='center left', handletextpad=0)

    ax = axes[1]

    npc = 10
    ax.plot(
        np.arange(1, 1 + npc),
        pca.explained_variance_ratio_.cumsum()[:npc],
        '-o',
    )

    ax.set_xlim(.5, npc + .5)
    ax.set_ylim(0, 1)

    majorticks = [1, 4, 7, 10]
    ax.set_xticks(majorticks)
    ax.set_xticks(sorted(set(range(1, npc)) - set(majorticks)), minor=True)
    auto_ticks(ax, 'y', nbins=5, minor=2)
    ax.xaxis.set_ticks_position('top')

    ax.set_xlabel('Number of PC')
    ax.set_ylabel('Cumulative explained variance fraction')
    ax.xaxis.set_ticks_position('top')
    ax.xaxis.set_label_position('top')

    for ax in axes:
        for s in ax.spines.values():
            s.set_visible(True)

    set_tight(w_pad=.5)


def boxplot(
        ax, percentiles, x=0, y=0, box_width=1,
        line_width=plt.rcParams['lines.linewidth'],
        color=(0, 0, 0), alpha=.6, zorder=10
):
    """
    Draw a minimal boxplot.

    `percentiles` must be a np.array of five numbers:

        whisker_low, quartile_1, median, quartile_3, whisker_high

    """
    pl, q1, q2, q3, ph = percentiles + y

    # IQR box
    ax.add_patch(patches.Rectangle(
        xy=(x - .5*box_width, q1),
        width=box_width, height=(q3 - q1),
        color=color, alpha=alpha, lw=0, zorder=zorder
    ))

    # median line
    ax.plot(
        [x - .5*box_width, x + .5*box_width], 2*[q2],
        lw=line_width, solid_capstyle='butt', color=color,
        zorder=zorder + 1
    )

    # whisker lines
    for y in [[q1, pl], [q3, ph]]:
        ax.plot(
            2*[x], y, lw=line_width, solid_capstyle='butt',
            color=color, alpha=alpha, zorder=zorder
        )


#@plot
def validation_all(system='PbPb5020'):
    """
    Emulator validation: normalized residuals and RMS error for each
    observable.

    """
    fig, (ax_box, ax_rms) = plt.subplots(
        nrows=2, figsize=figsize(1.25, aspect=.4),
        gridspec_kw=dict(height_ratios=[1.5, 1])
    )

    index = 1
    ticks = []
    ticklabels = []

    vdata = model.validation_data[system]
    emu = emulators[system]
    mean, cov = emu.predict(
        Design(system, validation=True).array,
        return_cov=True
    )

    for obs, subobslist in emu.observables:
        for subobs in subobslist:
            color = obs_color(obs, subobs)

            Y = vdata[obs][subobs]['Y']
            Y_ = mean[obs][subobs]
            S_ = np.sqrt(cov[(obs, subobs), (obs, subobs)].T.diagonal())

            Z = (Y_ - Y)/S_

            for i, percentiles in enumerate(
                    np.percentile(Z, [10, 25, 50, 75, 90], axis=0).T,
                    start=index
            ):
                boxplot(ax_box, percentiles, x=i, box_width=.8, color=color)

            rms = 100*np.sqrt(np.square(Y_/Y - 1).mean(axis=0))
            ax_rms.plot(
                np.arange(index, index + rms.size), rms, 'o', color=color
            )

            ticks.append(.5*(index + i))
            ticklabels.append(obs_label(obs, subobs))

            index = i + 2

    ax_box.set_xticks(ticks)
    ax_box.set_xticklabels(ticklabels)
    ax_box.tick_params('x', bottom=False, labelsize=plt.rcParams['font.size'])

    ax_box.set_ylim(-2.25, 2.25)
    ax_box.set_ylabel(r'Normalized residuals')

    q, p = np.sqrt(2) * special.erfinv(2*np.array([.75, .90]) - 1)
    ax_box.axhspan(-q, q, color='.85', zorder=-20)
    for s in [-1, 0, 1]:
        ax_box.axhline(s*p, color='.5', zorder=-10)

    ax_q = ax_box.twinx()
    ax_q.set_ylim(ax_box.get_ylim())
    ax_q.set_yticks([-p, -q, 0, q, p])
    ax_q.set_yticklabels([10, 25, 50, 75, 90])
    ax_q.tick_params('y', right=False)
    ax_q.set_ylabel(
        'Normal quantiles',
        fontdict=dict(rotation=-90),
        labelpad=4*plt.rcParams['axes.labelpad']
    )

    ax_rms.set_xticks([])
    ax_rms.set_yticks(np.arange(0, 16, 5))
    ax_rms.set_ylim(0, 15)
    ax_rms.set_ylabel('RMS % error')

    for y in ax_rms.get_yticks():
        ax_rms.axhline(y, color='.5', zorder=-10)

    for ax in fig.axes:
        ax.set_xlim(0, index - 1)
        ax.spines['bottom'].set_visible(False)


#@plot
def validation_example(
        system='PbPb2760',
        obs='dNch_deta', subobs=None,
        label=r'$dN_\mathrm{ch}/d\eta$',
        cent=(20, 30)
):
    """
    Example of emulator validation for a single observable.  Scatterplot of
    model calculations vs emulator predictions with histogram and boxplot of
    normalized residuals.

    """
    fig, axes = plt.subplots(
        ncols=2, figsize=figsize(.9, aspect=.6),
        gridspec_kw=dict(width_ratios=[3, 1])
    )

    ax_scatter, ax_hist = axes

    vdata = model.validation_data[system][obs][subobs]
    cent_slc = (slice(None), vdata['cent'].index(cent))
    y = vdata['Y'][cent_slc]

    mean, cov = emulators[system].predict(
        Design(system, validation=True).array,
        return_cov=True
    )
    y_ = mean[obs][subobs][cent_slc]
    std_ = np.sqrt(cov[(obs, subobs), (obs, subobs)].T.diagonal()[cent_slc])

    color = obs_color(obs, subobs)
    alpha = .6

    ax_scatter.set_aspect('equal')
    ax_scatter.errorbar(
        y_, y, xerr=std_,
        fmt='o', mew=.2, mec='white',
        color=color, alpha=alpha
    )
    dy = .03*y.ptp()
    x = [y.min() - dy, y.max() + dy]
    ax_scatter.plot(x, x, color='.4')
    ax_scatter.set_xlabel('Emulator prediction')
    ax_scatter.set_ylabel('Model calculation')
    ax_scatter.text(
        .04, .96, '{} {}–{}%'.format(label, *cent),
        horizontalalignment='left', verticalalignment='top',
        transform=ax_scatter.transAxes
    )

    zmax = 3.5
    zrange = (-zmax, zmax)

    z = (y_ - y)/std_

    ax_hist.hist(
        z, bins=30, range=zrange, density=True, histtype='stepfilled',
        orientation='horizontal', color=color, alpha=alpha
    )
    x = np.linspace(-zmax, zmax, 1000)
    ax_hist.plot(np.exp(-.5*x*x)/np.sqrt(2*np.pi), x, color='.25')

    box_x = .75
    box_width = .1

    boxplot(
        ax_hist, np.percentile(z, [10, 25, 50, 75, 90]),
        x=box_x, box_width=box_width,
        line_width=2*plt.rcParams['lines.linewidth'],
        color=color, alpha=alpha
    )

    guide_width = 2.5*box_width

    q, p = np.sqrt(2) * special.erfinv(2*np.array([.75, .90]) - 1)
    ax_hist.add_patch(patches.Rectangle(
        xy=(box_x - .5*guide_width, -q),
        width=guide_width, height=2*q,
        color='.85', zorder=-20
    ))
    for s in [-1, 0, 1]:
        ax_hist.plot(
            [box_x - .5*guide_width, box_x + .5*guide_width], 2*[s*p],
            color='.5', zorder=-10
        )

    ax_hist.set_ylim(zrange)
    ax_hist.spines['bottom'].set_visible(False)
    ax_hist.tick_params('x', bottom=False, labelbottom=False)
    ax_hist.set_ylabel('Normalized residuals')

    ax_q = ax_hist.twinx()
    ax_q.spines['bottom'].set_visible(False)
    ax_q.set_ylim(ax_hist.get_ylim())
    ax_q.set_yticks([-p, -q, 0, q, p])
    ax_q.set_yticklabels([10, 25, 50, 75, 90])
    ax_q.tick_params('y', right=False)
    ax_q.set_ylabel(
        'Normal quantiles',
        fontdict=dict(rotation=-90),
        labelpad=4*plt.rcParams['axes.labelpad']
    )


@plot
def correlation_matrices(system='pPb5020'):
    """
    Correlation (normalized covariance) matrices for model and experiment.

    """
    chain = mcmc.Chain()

    emu = emulators[system]
    emu_slices = [
        (obs, subobs, slc)
        for obs, subobs_slc in emu._slices.items()
        for subobs, slc in subobs_slc.items()
    ]

    design = Design(system)
    X = np.random.uniform(design.min, design.max).reshape(1, -1)
    emu_cov = emu.predict(X, return_cov=True)[1].array[0]

    fig, axes = plt.subplots(
        ncols=3, figsize=figsize(1.7, .47),
        gridspec_kw=dict(width_ratios=[1, 1, .02])
    )

    for (cov, slices, title), ax in zip([
            (emu_cov, emu_slices, 'Model (emulator)'),
            (chain._expt_cov[system], chain._slices[system], 'Experiment'),
    ], axes):
        s = np.sqrt(cov.diagonal())
        img = ax.imshow(
            cov / np.outer(s, s), vmin=-1, vmax=1,
            interpolation='nearest', cmap='RdBu'
        )

        ticks = []
        ticklabels = []

        for obs, subobs, slc in slices:
            ticks.append(.5*(slc.start + slc.stop - 1))
            ticklabels.append(obs_label(obs, subobs))

        ax.set_xticks(ticks)
        ax.set_yticks(ticks)
        ax.set_xticklabels(ticklabels)
        ax.set_yticklabels(ticklabels)
        ax.set_title(title, y=1.05)

        ax.tick_params(
            bottom=False, top=False, left=False, right=False,
            labelbottom=False, labeltop=True,
            pad=0
        )

        for s in ax.spines.values():
            s.set_visible(False)

    axes[0].tick_params(labelleft=False)
    for t in axes[1].get_yticklabels():
        t.set_horizontalalignment('center')
        t.set_x(-.05)

    cax = axes[-1]
    fig.colorbar(img, cax=cax, ticks=[-1, -.5, 0, .5, 1])
    cax.set_aspect(40)
    cax.yaxis.set_ticks_position('left')
    cax.set_title('Correlation', y=1.02, fontsize=fontsize['normal'])

    set_tight(fig, rect=(0, 0, 1, .96))


default_system = 'pPb5020'


@plot
def diag_pca(system=default_system):
    """
    Diagnostic: histograms of principal components and scatterplots of pairs.

    """
    Y = [g.y_train_ for g in emulators[system].gps]
    n = len(Y)
    ymax = np.ceil(max(np.fabs(y).max() for y in Y))
    lim = (-ymax, ymax)

    fig, axes = plt.subplots(nrows=n, ncols=n, figsize=2*(n,))

    for y, ax in zip(Y, axes.diagonal()):
        ax.hist(y, bins=30)
        ax.set_xlim(lim)

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        ax = axes[ny][nx]
        ax.scatter(Y[nx], Y[ny])
        ax.set_xlim(lim)
        ax.set_ylim(lim)
        axes[nx][ny].set_axis_off()

    for i in range(n):
        label = 'PC {}'.format(i)
        axes[-1][i].set_xlabel(label)
        axes[i][0].set_ylabel(label)


def _diag_emu(system=default_system, pcs=None, params=None, label_all=True):
    """
    Diagnostic: plots of each principal component vs each input parameter,
    overlaid by emulator predictions at several points in design space.

    """
    gps = emulators[system].gps
    pcs = (
        range(len(gps)) if pcs is None else
        [p if p >= 0 else (len(gps) + p) for p in pcs]
    )
    nrows = len(pcs)

    design = Design(system)
    if params is None:
        params = design.keys
    ncols = len(params)

    fig, axes = plt.subplots(
        nrows=nrows, ncols=ncols,
        figsize=figsize((.5 if label_all else .375)*ncols, .62*nrows/ncols),
        sharex=(False if label_all else 'col'),
        sharey=(False if label_all else 'row')
    )

    ymax = np.ceil(2*max(np.fabs(gps[pc].y_train_).max() for pc in pcs))/2
    ylim = (-ymax, ymax)

    tmax = int(ymax)
    yticksmajor = [-tmax, 0, tmax]
    yticksminor = list(range(-tmax + 1, 0)) + list(range(1, tmax))

    for pc, row in zip(pcs, axes):
        gp = gps[pc]
        y = gp.y_train_

        for param, ax in zip(params, row):
            i = design.keys.index(param)
            x = gp.X_train_[:, i]
            ax.plot(
                x, y, 'o',
                markersize=.4*plt.rcParams['lines.markersize'],
                color='.7',
                zorder=-30
            )

            xlim = design.range[i]
            x = np.linspace(xlim[0], xlim[1], 100)
            X = np.empty((x.size, gp.X_train_.shape[1]))

            for r, c in [(.2, 'purple'), (.5, 'blue'), (.8, 'green')]:
                X[:] = r*design.min + (1 - r)*design.max
                X[:, i] = x
                mean, std = gp.predict(X, return_std=True)

                color = colors[c]
                ax.plot(
                    x, mean,
                    linewidth=.8*plt.rcParams['lines.linewidth'],
                    color=color,
                    zorder=-10
                )
                ax.fill_between(
                    x, mean - std, mean + std,
                    lw=0, color=color, alpha=.3, zorder=-20
                )

            ax.set_xlim(xlim)
            ax.set_ylim(ylim)

            auto_ticks(ax, 'x', nbins=3, minor=2)
            ax.set_yticks(yticksmajor)
            ax.set_yticks(yticksminor, minor=True)

            if label_all or ax.is_last_row():
                ax.set_xlabel(design.labels[i])
            if label_all or ax.is_first_col():
                ax.set_ylabel('PC {}'.format(pc + 1))

    set_tight(fig, w_pad=.5, h_pad=.25)


@plot
def diag_emu_all():
    _diag_emu()


@plot
def diag_emu_partial():
    _diag_emu(
        pcs=[0, 2, -1],
        params=['trento_p', 'tau_fs', 'etas_min'],
        label_all=False
    )


def cms_radius(npartons=1, sampling_radius=.88, parton_width=.88, size=10**4):
    """
    Find center-of-mass RMS radius for an ensemble of sampled protons
    with partonic substructure

    """
    # parton sampling radius
    size = 2*npartons*int(size / (2*npartons))
    parton_radius = np.sqrt(sampling_radius**2 - parton_width**2)

    # sample protons
    protons = np.random.normal(
        scale=parton_radius, size=size
    ).reshape(npartons, 2, -1)

    # recenter
    centers = protons.mean(axis=0)
    protons -= centers

    # mesh grid
    l = np.linspace(-4*sampling_radius, 4*sampling_radius, 10**2)
    xx, yy = np.meshgrid(l, l)

    # mesh grid radii
    rr_sq = xx**2 + yy**2
    rr = np.sqrt(rr_sq)

    # place a quark
    def quark(xx, yy):
        norm = 1/(2*np.pi*parton_width**2*npartons)
        return norm * np.exp(-(xx**2 + yy**2)/(2*parton_width**2))

    # place a proton
    def proton(quarks):
        return np.sum([quark(xx-xi, yy-yi) for (xi, yi) in quarks.T], axis=0)

    # proton rms radius in cms frame
    def rms_radius(rho):
        return np.sqrt(np.average(rr_sq, weights=rho/rr))

    # ensemble averaged rms radius
    logging.info(
        "calculating rms proton radius, npartons = {}".format(npartons)
    )
    return np.mean([rms_radius(proton(quarks)) for quarks in protons.T], axis=0)


@plot
def proton_radius():
    """
    Protons rms radius in the center of mass frame, as a function of parton
    number

    """
    # figure size
    plt.figure(figsize=figsize(.5))

    # proton dimensions
    sampling_radius = .88
    parton_width = .2
    nparton_values = list(range(1, 11))

    # protons rms radii in com frame
    radii = [
        cms_radius(
            npartons=npartons,
            sampling_radius=sampling_radius,
            parton_width=parton_width,
            size=10**4
        ) for npartons in nparton_values
    ]

    # plot model results
    plt.plot(nparton_values, radii, 'o', label='parton number')
    plt.axhline(sampling_radius, color=offblack, label='sampling radius')

    # annotate parameters
    plt.annotate(
        '\n'.join([
            r'proton sampling radius${} = .88$ fm',
            r'parton width${} = .2$ fm'
        ]), xy=(.95, .05), xycoords='axes fraction', ha='right'
    )

    # plot attributes
    plt.xlabel('parton number')
    plt.ylabel('proton rms radius [fm]')
    plt.ylim(0, 1)
    set_tight()


@plot
def grid_error():
    """
    Scatter plot observables calculated on a grid with grid scale = 0.2 against
    observables calculated on a grid with grid scale = 0.1.

    """
    system = 'pPb5020'

    obs_list = [
        ('dNch_deta', r'$dN_\mathrm{ch}/d\eta$'),
        ('mean_pT', r'mean $p_T$ [GeV]'),
        ('v2', r'$|Q_2|/M$'),
        ('v3', r'$|Q_3|/M$'),
    ]

    fig, axes = plt.subplots(ncols=4, nrows=1, figsize=figsize(1, aspect=.3))

    fine_design_points, coarse_design_points = (
        [Path(
            '/var/phy/project/nukeserv/jsm55',
            'hic-events/qm18-grid-scale',
            'grid-scale-{}'.format(gs),
            'events/{}.dat'.format(p)
        ) for p in Design(system).points if int(p) != 228]
        for gs in (.1, .2)
    )

    fine_events, coarse_events = [
        [ev for p, ev in model.ModelData(system, *design_points).design_events]
        for design_points in (fine_design_points, coarse_design_points)
    ]

    def obs(event, name):
        flow = event['flow']['cms']
        TINY = 1e-12
        return dict(
            dNch_deta=event['dNch_deta'],
            mean_pT=event['mean_pT']['pT'],
            v2=np.absolute(flow['Qn'][1])/(flow['N'] + TINY),
            v3=np.absolute(flow['Qn'][2])/(flow['N'] + TINY),
        )[name]

    for ax, (name, label) in zip(axes.flat, obs_list):
        x = [obs(ev, name) for ev in itertools.chain(*fine_events)]
        y = [obs(ev, name) for ev in itertools.chain(*coarse_events)]
        ax.scatter(x, y, s=15, edgecolors='white', linewidths=.2)

        xy_max = np.nanmax(np.append(x, y))
        ax.plot((0, xy_max), (0, xy_max), color=offblack)

        if ax.is_last_row():
            ax.set_xlabel('grid scale 0.1', fontsize=fontsize['tiny'])
        if ax.is_first_col():
            ax.set_ylabel('grid scale 0.2', fontsize=fontsize['tiny'])

        ax.set_title(label, y=.9, fontsize=fontsize['tiny'])
        ax.set_aspect('equal')
        auto_ticks(ax, 'x', nbins=3)
        auto_ticks(ax, 'y', nbins=3)

    set_tight()


def run_cmd(*args, stdout=subprocess.PIPE):
    """
    Run and log a subprocess.

    """
    cmd = ' '.join(args)
    logging.info('running command: %s', cmd)

    try:
        proc = subprocess.run(
            cmd.split(), check=True,
            stdout=stdout, stderr=subprocess.STDOUT,
            universal_newlines=True
        )
    except subprocess.CalledProcessError as e:
        logging.error(
            'command failed with status %d:\n%s',
            e.returncode, e.output.strip('\n')
        )
        raise
    else:
        return proc


def trento(system, grid_max, grid_step, parton_number=1, nucleon_width=.88,
           parton_width=.88, filename='event.hdf'):
    """
    Generates and returns a trento event with the specified arguments

    """
    try:
        os.remove(filename)
    except FileNotFoundError:
        pass

    run_cmd(
        'trento {}'.format(system),
        '--random-seed 492835',
        '--number-events 1',
        '--b-max 0',
        '--reduced-thickness 1',
        '--fluctuation 10000',
        '--nucleon-width {}'.format(nucleon_width),
        '--parton-width {}'.format(parton_width),
        '--parton-number {}'.format(parton_number),
        '--nucleon-min-dist .9',
        '--cross-section 7',
        '--grid-max {}'.format(grid_max),
        '--grid-step {}'.format(grid_step),
        '--output {}'.format(filename),
        )

    with h5py.File(filename, 'r') as f:
        for ev in f.values():
            os.remove(filename)
            return np.array(ev)


def trento_imshow(system, grid_max, grid_step,
                  nucleon_width=.88, parton_width=.88, parton_number=1):
    """
    Lead nuclear thickness function with nucleon d.o.f.

    """
    fig = plt.figure(figsize=figsize(.25, 1), frameon=False)
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    ev = trento(
        system, grid_max, grid_step,
        nucleon_width=nucleon_width,
        parton_width=parton_width,
        parton_number=parton_number,
    )
    cmap = cmap_to_alpha(cmap=plt.cm.inferno, fraction=.2)
    ax.imshow(ev, cmap=cmap, interpolation='none')


@plot
def lead():
    """ Lead nucleus """
    trento_imshow('Pb Pb', 11, .1, nucleon_width=1.1)


@plot
def lead_partons():
    """ Lead nucleus with sub-structure """
    trento_imshow('Pb Pb', 11, .1, parton_number=1, parton_width=.6)


@plot
def proton():
    """ Gaussian proton """
    trento_imshow('p p', 2.8, .05)


@plot
def proton_partons():
    """ Proton with sub-structure """
    trento_imshow('p p', 2.8, .05, nucleon_width=1.1, parton_number=3, parton_width=.6)


def nucleus():
    """
    Nucleon coordinates and participant status

    """
    file_path = str(plotdir / '.nucleons.dat')
    nucl_data = np.loadtxt(file_path)

    return np.split(nucl_data, 2)


@plot
def entropy_deposition(aspect=.75):
    """
    Schematic drawing of how entropy deposition scales with target density

    """
    plt.figure(figsize=figsize(1/3))

    x = np.linspace(1e-6, 5, 1000)
    p = 1e-3

    dsdy = (0.5*(1**p + x**p))**(1/(p + 1e-6))
    plt.plot(x, dsdy, color=theme)

    plt.xlabel(r'Local target thickness')
    plt.ylabel(r'Entropy deposited')
    plt.xticks([])
    plt.yticks([])

    set_tight()


def plot_nucleons(ax, gray_spect=False):
    """
    Plot participant/spectator nucleons

    """
    colors = [plt.cm.Oranges, plt.cm.Blues]

    for nucl, cmap in zip(nucleus(), colors):

        # unpack coord
        x, y, hit = nucl.T

        # spectators
        low, high = (.8, .9) if gray_spect else (.6, .8)
        c = np.random.uniform(low=low, high=high, size=sum(hit == 0))
        ax.scatter(x[hit == 0], y[hit == 0], c=c, s=300, lw=0.1, vmin=0, vmax=1,
                edgecolor=offblack, cmap=plt.cm.gray if gray_spect else cmap)

        # participants
        c = np.random.uniform(low=.6, high=.8, size=sum(hit == 1))
        ax.scatter(x[hit == 1], y[hit == 1], c=c, s=300, lw=0.1, vmin=0, vmax=1,
                cmap=cmap, edgecolors=offblack)


def thickness_functions(xx, yy):
    """
    Nuclear thickness functions as scalar fields

    """
    parta, partb = [nucl[nucl[:, 2] == 1] for nucl in nucleus()]

    def gaussian(x0, y0, w=.88):
        """
        Proton thickness function

        """
        x = xx - x0
        y = yy - y0
        return np.exp(-(x**2 + y**2)/(2*w**2))

    def thickness(xvals, yvals):
        """
        participant thickness function

        """
        return sum([gaussian(x, y) for (x, y) in zip(xvals, yvals)])

    TA, TB = [thickness(x, y) for (x, y, _) in (parta.T, partb.T)]

    return TA, TB


@plot
def trento_model_nuclei():
    """
    Example nucleon positions

    """
    fig = plt.figure(figsize=figsize(.5, .75))
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    plot_nucleons(ax, gray_spect=False)

    ax.set_aspect('equal')
    ax.set_xlim(-11.5, 11.5)
    ax.set_ylim(-9, 9)


@plot
def trento_model_part():
    """
    Glauber participant nucleons

    """
    fig = plt.figure(figsize=figsize(.5, .75))
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    plot_nucleons(ax, gray_spect=True)

    ax.set_aspect('equal')
    ax.set_xlim(-11.5, 11.5)
    ax.set_ylim(-9, 9)


@plot
def trento_model_thickness():
    """
    Participant thickness functions

    """
    fig = plt.figure(figsize=figsize(.5, .75))
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    # nucleon coordinates
    nucla, nuclb = nucleus()

    for nucl, fill in [(nucla, True), (nuclb, True)]:

        # unpack coord
        x, y, hit = nucl.T

        # spectators
        c = np.random.uniform(low=.8, high=.9, size=sum(hit == 0))
        ax.scatter(x[hit == 0], y[hit == 0], c=c if fill else 'none', s=300,
                   lw=0.1, vmin=0, vmax=1, edgecolor=offblack, cmap=plt.cm.gray)


    xmax, ymax, dxy = (11.5, 9, .05)
    lx = np.arange(-xmax, xmax + dxy, dxy)
    ly = np.arange(-ymax, ymax + dxy, dxy)
    xx, yy = np.meshgrid(lx, ly)

    TA, TB = thickness_functions(xx, yy)

    for T, cmap in [(TA, plt.cm.Oranges_r), (TB, plt.cm.PuBu_r)]:
        ax.imshow(T, cmap=cmap_to_alpha(cmap=cmap, fraction=.1),
                  extent=(-xmax, xmax, -ymax, ymax), origin='lower', zorder=2)

    ax.set_aspect('equal')
    ax.set_xlim(-xmax, xmax)
    ax.set_ylim(-ymax, ymax)


@plot
def trento_model_entropy():
    """
    Reduced thickness function for an example event

    """
    fig = plt.figure(figsize=figsize(.5, .75))
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    # scatter plot spectators
    for nucl in nucleus():

        # unpack coord
        x, y, hit = nucl.T

        # spectators
        c = np.random.uniform(low=.8, high=.9, size=sum(hit == 0))
        ax.scatter(x[hit == 0], y[hit == 0], c=c, s=300, lw=0.1, vmin=0, vmax=1,
                edgecolor=offblack, cmap=plt.cm.gray)

    xmax, ymax, dxy = (11.5, 9, .05)
    lx = np.arange(-xmax, xmax + dxy, dxy)
    ly = np.arange(-ymax, ymax + dxy, dxy)
    xx, yy = np.meshgrid(lx, ly)

    TA, TB = thickness_functions(xx, yy)
    TR = np.sqrt(TA*TB)

    ax.imshow(TR, cmap=cmap_to_alpha(), extent=(-xmax, xmax, -ymax, ymax),
              origin='lower', zorder=2)

    ax.set_aspect('equal')
    ax.set_xlim(-xmax, xmax)
    ax.set_ylim(-ymax, ymax)


@plot
def trento_model_freestream():
    """
    Reduced thickness function for an example event

    """
    fig = plt.figure(figsize=figsize(.5, .75))
    ax = plt.Axes(fig, [0., 0., 1., 1.])
    ax.set_axis_off()
    fig.add_axes(ax)

    # scatter plot spectators
    for nucl in nucleus():

        # unpack coord
        x, y, hit = nucl.T

        # spectators
        c = np.random.uniform(low=.8, high=.9, size=sum(hit == 0))
        ax.scatter(x[hit == 0], y[hit == 0], c=c, s=300, lw=0.1, vmin=0, vmax=1,
                edgecolor=offblack, cmap=plt.cm.gray)

    xmax, ymax, dxy = (11.5, 9, .05)
    lx = np.arange(-xmax, xmax + dxy, dxy)
    ly = np.arange(-ymax, ymax + dxy, dxy)
    xx, yy = np.meshgrid(lx, lx)

    TA, TB = thickness_functions(xx, yy)
    TR = np.sqrt(TA*TB)

    fs = freestream.FreeStreamer(TR, xmax, 1)
    e = fs.energy_density()
    u0, ux, uy = [fs.flow_velocity(i) for i in range(3)]
    vx, vy = [u/u0 for u in (ux, uy)]

    ax.imshow(e, cmap=cmap_to_alpha(), extent=(-xmax, xmax, -xmax, xmax),
              origin='lower', zorder=2)

    fx, fy = [np.ma.masked_where(e < .1, e*v) for v in (vx, vy)]
    xx, yy, fx, fy = [d[::20, ::20] for d in (xx, yy, fx, fy)]
    ax.quiver(xx, yy, fx, fy, zorder=3)

    ax.set_aspect('equal')
    ax.set_xlim(-xmax, xmax)
    ax.set_ylim(-ymax, ymax)


@plot
def coupling():
    """
    Cartoon showing how free streaming approximated the time dependence of the
    fluid coupling as a step function

    """
    plt.figure(figsize=figsize(.3))

    x = np.linspace(0, 1, 10**3)
    y = np.heaviside(x - .6, 1)
    plt.plot(x, y, color=theme)

    plt.annotate('free stream', xy=(.3, .1), xycoords='data', ha='center')
    plt.annotate('hydro', xy=(.8, 1.1), xycoords='data', ha='center')
    plt.annotate(r'$\tau_\mathrm{fs}$', xy=(.63, .5), xycoords='data',
                 ha='left', va='center')

    plt.xticks([])
    plt.xlabel('Time')

    plt.yticks([0, 1.4], ['0', 'inf'])
    plt.ylim(-.1, 1.5)
    plt.ylabel('Coupling')

    set_tight()


@plot
def collision_profile():
    """
    The collision probability Pcoll(b) for p+p collisions

    """
    plt.figure(figsize=figsize(.5))

    sigma_nn = 6.4
    b = np.linspace(0, 5, 1000)

    # black-disk proton
    disk_radius = np.sqrt(sigma_nn/np.pi)
    black_disk = np.heaviside(-(b - disk_radius), 1)
    plt.plot(b, black_disk, color=offblack, label='black disk')

    # Gaussian protons
    for w in [.4, .7, .9]:
        norm = 4*np.pi*w**2

        def fit_xsection(x, A=6):
            c = A**2/4
            rhs = sigma_nn/norm
            return c - special.expi(-np.exp(x)) + special.expi(-np.exp(x-c)) - rhs

        cross_sec_param = brentq(fit_xsection, -10, 20)
        pcoll = 1 - np.exp(-np.exp(cross_sec_param - .25*b**2/w**2))
        plt.plot(b, pcoll, label=r'$w={}$ [fm]'.format(w))

    plt.xlim(0, 5)
    plt.xlabel('$b$ [fm]')
    plt.ylabel(r'$P_\mathrm{coll}(b)$')

    plt.legend(
        title=r'$\sigma_\mathrm{nn}^\mathrm{inel}=6.4$ fm$^2$',
        bbox_to_anchor=(.5, .15)
    )

    set_tight()


@plot
def proton_overlap():
    """
    The proton-proton overlap function Tpp

    """
    plt.figure(figsize=figsize(.5))

    def gaussian(x, loc=0, std=1):
        return np.exp(-(x - loc)**2/(2*std**2)) / np.sqrt(2*np.pi*std**2)

    x = np.linspace(-2.7, 2.7, 1000)
    Tp1, Tp2 = [gaussian(x, mu, .6) for mu in (-.6, .6)]
    Tpp = Tp1*Tp2

    plt.plot(x, 4*Tpp, color=theme, label=r'$4 \times T_{pp}$')
    plt.plot(x, Tp1, color=offblack, dashes=(8, 4), label=r'$T_p$')
    plt.plot(x, Tp2, color=offblack, dashes=(8, 4))

    plt.annotate('b', xy=(0, .7), va='bottom', ha='center')
    plt.annotate(
        s='', xy=(-.6, .7), xytext=(.6, .7),
        arrowprops=dict(arrowstyle='<->', shrinkA=0, shrinkB=0),
        color=offblack
    )

    plt.xlabel('x [fm]')
    plt.ylabel('Thickness [fm$^{-1}$]')
    plt.ylim(0, .8)

    plt.legend(handlelength=1.3, bbox_to_anchor=(.67, .67), markerfirst=False)

    set_tight()


@plot
def observable_normality(system='pPb5020'):
    model_data = model._data(system)
    emu = emulators[system]

    observables = [
        (obs, subobs, y)
        for (obs, subobslist) in emu.pPb5020
        for subobs in subobslist
        for y in model_data[obs][subobs]['Y'].T
    ]

    nobs = len(observables)

    fig, axes = plt.subplots(
        nrows=nobs, ncols=nobs,
        figsize=figsize(relwidth=10, aspect=1)
    )

    for (obs, subobs, y), ax in zip(observables, axes.diagonal()):
        ax.hist(y, bins=30)
        ax.set_xticklabels([])
        ax.set_yticklabels([])
        ax.set_title('{} {}'.format(obs, subobs if subobs else ''))

    for ny, nx in zip(*np.tril_indices_from(axes, k=-1)):
        obs, subobs, Y = zip(*observables)
        ax = axes[ny][nx]
        ax.scatter(Y[nx], Y[ny])
        axes[nx][ny].set_axis_off()

    set_tight(fig)


@plot
def statistics():
    """
    Event statistics in each p-Pb trigger bin

    """
    plt.figure(figsize=figsize())
    ax = plt.gca()

    system = 'pPb5020'

    files = [
        Path(workdir, 'model_output', 'main', system, '{}.dat'.format(p))
        for p in Design(system, validation=False).points
    ]

    events = [
        tuple(event)
        for point, events in model.ModelData(system, *files).design_events
        for event in events['trigger']
    ]

    counter = Counter(events).most_common()
    shift = 0

    labels = ['flow bins', 'minimum bias', 'mean $p_T$ bins']

    for label, counts in zip(labels, np.split(counter, [8, 9])):
        lbl, height = zip(*counts)
        loc = np.arange(len(lbl))
        ax.bar(loc + shift, height, label=label)
        shift += len(lbl)

    plt.ylabel('Events')
    plt.xticks([])
    plt.legend()

    set_tight()


@plot
def entropy_scaling(system='pPb5020'):
    """
    Plot initial entropy vs final dNch/deta

    """
    ncols= 10
    nrows = 5
    fig, axes = plt.subplots(
        nrows=nrows, ncols=ncols,
        figsize=figsize(relwidth=3, aspect=nrows/ncols)
    )

    data = Path(workdir, 'model_output', 'main', system)

    design = Design(system, validation=False)
    files = [data / '{}.dat'.format(p) for p in design.points]
    model_data = model.ModelData(system, *files)

    def powerlaw(x, a, b, c):
        return a*x**b + c

    for ax, (pt, ev), in zip(axes.flat, model_data.design_events):
        x, y = [ev[k] for k in ('init_entropy', 'dNch_deta')]

        y = y[x.argsort()]
        x = np.sort(x)

        try:
            nonzero = (y > 0)
            popt, pcov = curve_fit(powerlaw, x[nonzero], y[nonzero])

            xval = np.linspace(0, max(x[nonzero]), 100)
            ax.plot(xval, powerlaw(xval, *popt), color=offblack, zorder=1)
        except RuntimeError:
            pass

        ax.plot(x, y, 'o', zorder=0)
        ax.set_title(str(pt))

    set_tight()


@plot
def cross_validation():
    """
    Plot the distribution of emulator quantiles for each observable.
    If the emulator is working, the distribution of residuals should
    be that of a standard normal distribution.

    """
    plots = _observables_plots()

    fig, axes = plt.subplots(
        nrows=len(systems), ncols=len(plots), sharey=True,
        figsize=figsize(relwidth=1, aspect=aspect*len(systems)/len(plots))
    )

    kf = KFold(n_splits=2, shuffle=False)
    quantiles = {}

    # adds items to a nested dictionary
    def update(d, u):
        for k, v in u.items():
            if isinstance(v, Mapping):
                d[k] = update(d.get(k, {}), v)
            else:
                d[k] = v
        return d

    # loop over collision systems
    for row, system in enumerate(systems):
        design = Design(system)

        # loop over k-fold training and test points
        for train_index, test_index in kf.split(design.array):
            test_points, train_points = [
                [design.points[index] for index in indices]
                for indices in (test_index, train_index)
            ]

            # train emulator on training points, test on testing points
            emu = Emulator(system, exclude_points=test_points)
            mean, cov = emu.predict(design.array[test_index], return_cov=True)

            # calculate and record emulator quantiles for each observable
            for col, plot in enumerate(plots):
                for (obs, subobs, label) in plot['subplots']:
                    # actual model values
                    Y = model.data[system][obs][subobs]['Y'][test_index]
                    # emulator predictions
                    Y_ = mean[obs][subobs]
                    S_ = np.sqrt(cov[(obs, subobs), (obs, subobs)].T.diagonal())
                    # quantiles
                    Q = (Y_ - Y)/S_

                    try:
                        Q_ = quantiles[system][obs][subobs]
                        quantiles[system][obs][subobs] = np.append(Q_, Q.ravel())
                    except KeyError:
                        update(quantiles, {system: {obs: {subobs: Q.ravel()}}})

        # plot quantiles
        for col, plot in enumerate(plots):
            for (obs, subobs, label) in plot['subplots']:
                ax = axes[row][col] if len(systems) > 1 else axes[col]

                # standard normal distribution
                std = np.linspace(-4, 4, 10**3)
                norm_dist = (1/np.sqrt(2*np.pi))*np.exp(-std**2/2)
                ax.plot(std, norm_dist, color=offblack)

                # emulator quantiles
                Q = quantiles[system][obs][subobs]
                ax.hist(Q, bins=40, histtype='step', density=True,
                        label=label['label'])

                ax.set_xlim(-5, 5)
                ax.set_ylim(0, .6)
                ax.set_xticks([-4, -2, 0, 2, 4])
                xlabel = r'$(y_\mathrm{pred} - y_\mathrm{obs})/\sigma_\mathrm{pred}$'
                ax.set_xlabel(r'{}'.format(xlabel))

                ax.axes.get_yaxis().set_visible(False)
                ax.legend(loc=1, bbox_to_anchor=(1.02, 1.1))

    set_tight(fig)


if __name__ == '__main__':
    import argparse
    from matplotlib.mathtext import MathTextWarning

    warnings.filterwarnings(
        'ignore',
        category=MathTextWarning,
        message='Substituting with a symbol from Computer Modern.'
    )
    warnings.filterwarnings(
        'ignore',
        category=UserWarning,
        message=r"'[\w\.]+' can not be subsetted into a Type 3 font."
    )

    choices = list(plot_functions)

    def arg_to_plot(arg):
        arg = Path(arg).stem
        if arg not in choices:
            raise argparse.ArgumentTypeError(arg)
        return arg

    parser = argparse.ArgumentParser(description='generate plots')
    parser.add_argument(
        '--paper', action='store_true',
        help='use paper style: cm serif font, true black text + axes'
    )
    parser.add_argument(
        'plots', nargs='*', type=arg_to_plot, metavar='PLOT',
        help='{} (default: all)'.format(', '.join(choices).join('{}'))
    )
    args = parser.parse_args()

    if args.paper:
        plt.rcParams.update({
            'font.family': 'serif',
            'font.serif': ['CMU Serif'],
            'mathtext.fontset': 'cm',
            'text.color': 'black',
            'axes.edgecolor': 'black',
            'axes.labelcolor': 'black',
            'xtick.color': 'black',
            'ytick.color': 'black',
        })

    if args.plots:
        for p in args.plots:
            plot_functions[p]()
    else:
        for f in plot_functions.values():
            f()
